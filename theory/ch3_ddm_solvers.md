# General
Domain Decomposition Methods (DDM) divide the original physical model into smaller subdomains, which are processed independently and periodically coordinate to solve the original problem. This section lists some common characteristics of most DDMs.

Freedom degrees (dofs) of each subdomain are divided into boundary, which correspond to nodes on the boundary between two or more subdomains, and internal, which correspond to nodes belonging only to one subdomain. E.g. in an elasticity problem, if **u**<sup>s</sup> are the displacements corresponding to the dofs of subdomain *s*, *b* denotes boundary dofs and *i* denotes internal dofs:

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{u}^s&space;=&space;\begin{bmatrix}&space;\mathbf{u}^s_b&space;\\&space;\mathbf{u}^s_i&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{u}^s&space;=&space;\begin{bmatrix}&space;\mathbf{u}^s_b&space;\\&space;\mathbf{u}^s_i&space;\end{bmatrix}" title="\mathbf{u}^s = \begin{bmatrix} \mathbf{u}^s_b \\ \mathbf{u}^s_i \end{bmatrix}" /></a>

Many computationally intensive operations can then be performed for each subdomain independently. E.g. in an elasticity problem, the stiffness matrices **K** and force vectors (right hand side vectors) **f** can be calculated for each subdomain and then divided into their "internal" and "boundary" parts:

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{K}^s&space;=&space;\begin{bmatrix}&space;\mathbf{K}^s_{bb}&space;&&space;\mathbf{K}^s_{bi}\\&space;\mathbf{K}^s_{ib}&space;&&space;\mathbf{K}^s_{ii}&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{K}^s&space;=&space;\begin{bmatrix}&space;\mathbf{K}^s_{bb}&space;&&space;\mathbf{K}^s_{bi}\\&space;\mathbf{K}^s_{ib}&space;&&space;\mathbf{K}^s_{ii}&space;\end{bmatrix}" title="\mathbf{K}^s = \begin{bmatrix} \mathbf{K}^s_{bb} & \mathbf{K}^s_{bi}\\ \mathbf{K}^s_{ib} & \mathbf{K}^s_{ii} \end{bmatrix}" /></a>   
<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{f}^s&space;=&space;\begin{bmatrix}&space;\mathbf{f}^s_b&space;\\&space;\mathbf{f}^s_i&space;\end{bmatrix}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{f}^s&space;=&space;\begin{bmatrix}&space;\mathbf{f}^s_b&space;\\&space;\mathbf{f}^s_i&space;\end{bmatrix}" title="\mathbf{f}^s = \begin{bmatrix} \mathbf{f}^s_b \\ \mathbf{f}^s_i \end{bmatrix}" /></a>

Apart from the examples above, many other operations may be used by specific solvers, such as factorizing the stiffness matrix or its submatrices, calculating Schur complements, etc. However they can usually be performed for each subdomain independently. There is also the need to transfer various quantities between subdomain and global vectors and matrices, especially those corresponding to boundary dofs. This is achieved by using special boolean matrices, whose entries are 0 or 1. E.g to map boundary displacements from global to subdomain level, we use the boolean matrix **L**<sub>b</sub>:

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{u}^s_b&space;=&space;\mathbf{L}^s_b&space;\cdot&space;\mathbf{\bar{u}}_b" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{u}^s_b&space;=&space;\mathbf{L}^s_b&space;\cdot&space;\mathbf{\bar{u}}_b" title="\mathbf{u}^s_b = \mathbf{L}^s_b \cdot \mathbf{\bar{u}}_b" /></a>

In addition, global forces and stiffnesses can be obtained by adding the contribution of each subdomain after applying the inverse map:

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{\bar{f}}_b&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{f}^s_b" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{\bar{f}}_b&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{f}^s_b" title="\mathbf{\bar{f}}_b = \sum_{s=1}^{N_s} \left( \mathbf{L}^s_b \right )^T \cdot \mathbf{f}^s_b" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{\bar{K}}_{bb}&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{K}^s_{bb}&space;\cdot&space;\mathbf{L}^s_b" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{\bar{K}}_{bb}&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{K}^s_{bb}&space;\cdot&space;\mathbf{L}^s_b" title="\mathbf{\bar{K}}_{bb} = \sum_{s=1}^{N_s} \left( \mathbf{L}^s_b \right )^T \cdot \mathbf{K}^s_{bb} \cdot \mathbf{L}^s_b" /></a>

where N<sub>s</sub> is the number of subdomains. After determining the quantities above, a typical DDM solver constructs and solves an interface problem. Interface problem are linear systems that involve only boundary dofs and are thus much smaller than the original one. They are usually solved by using an iterative method, e.g. PCG if the interface problem matrix is symmetric positive definite. Iterative methods require matrix-vector multiplications, which in DDM are performed in a distributed fashion. E.g instead of calculating the global **K**<sub>bb</sub> as above, which requires a lot of coordination and extra memory, and then multiplying vectors,

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{\bar{y}}^s&space;=&space;\mathbf{\bar{K}}^s_{bb}&space;*&space;\mathbf{\bar{x}}^s" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{\bar{y}}^s&space;=&space;\mathbf{\bar{K}}^s_{bb}&space;*&space;\mathbf{\bar{x}}^s" title="\mathbf{\bar{y}}^s = \mathbf{\bar{K}}^s_{bb} * \mathbf{\bar{x}}^s" /></a>

one would typically multiply the vector with each subdomain **K**<sub>bb</sub> and then add the results:

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{x}^s&space;=&space;\mathbf{L}^s_b&space;\cdot&space;\mathbf{\bar{x}}" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{x}^s&space;=&space;\mathbf{L}^s_b&space;\cdot&space;\mathbf{\bar{x}}" title="\mathbf{x}^s = \mathbf{L}^s_b \cdot \mathbf{\bar{x}}" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{y}^s&space;=&space;\mathbf{\bar{K}}^s_{bb}&space;*&space;\mathbf{x}^s" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{y}^s&space;=&space;\mathbf{\bar{K}}^s_{bb}&space;*&space;\mathbf{x}^s" title="\mathbf{y}^s = \mathbf{\bar{K}}^s_{bb} * \mathbf{x}^s" /></a>

<a href="https://www.codecogs.com/eqnedit.php?latex=\mathbf{\bar{y}}_b&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{y}^s_b" target="_blank"><img src="https://latex.codecogs.com/gif.latex?\mathbf{\bar{y}}_b&space;=&space;\sum_{s=1}^{N_s}&space;\left(&space;\mathbf{L}^s_b&space;\right&space;)^T&space;\cdot&space;\mathbf{y}^s_b" title="\mathbf{\bar{y}}_b = \sum_{s=1}^{N_s} \left( \mathbf{L}^s_b \right )^T \cdot \mathbf{y}^s_b" /></a>

Since iterative methods are used, a preconditioner is always necessary. Each DDM defines its own preconditioners. DDM preconditioners are also stored and used in a distributed fashion, like the matrix-vector multiplication shown above: each subdomain stores its own contribution to the preconditioner matrix and during the preconditioning step, each preconditioner submatrix is applied independently and the results are added. 

The most efficient DDMs also comprise a coarse problem, which is different for each method. The coarse problem of a DDM is a linear system contained in the interface problem and its purpose is to speed up the distribution of the global error among subdomains. The coarse problem is much smaller than the interface problem and it is solved during each iteration of the iterative method used for the interface problem. In general, the coarse problem tries to represent the behaviour of each subdomain using a very limited number of dofs or other features.

# Advantages and drawbacks

DDM solvers are among the most efficient ones for computationally intensive problems. Most operations are performed independently for each subdomain, therefore they can be run in parallel and coordination is needed only for global level operations, which are typically fewer and lightweight. Since each subdomain defines its own matrices, distributed memory systems (e.g. many networked computers) can be used to satisfy the memory requirements of even the largest problems. Thus, DDM solvers can leverage all the power of modern computational systems to substantially reduce the time needed for large scale simulations.

Compared to iterative solvers, the iterations required by the most efficient DDMs require significantly less iterations and are less sensitive to the linear system matrix size and condition. The preconditioner is also usually defined by the DDM, instead of being left to the user's choice. Moreover DDMs that perform matrix factorization, do so at subdomain level or during the coarse problem preparation. Compared to direct solvers, the size and bandwidth of these matrices is significantly smaller, which alleviates most of the problems direct solvers face for 3D and some 2D problems. 

On the other hand, applying a DDM is not as straightforward, since the original physical model must also be decomposed into subdomains. In addition every analysis operation, including the solution of linear systems, must take into account this decomposition. Furthermore coordinating between subdomains and setting up the auxiliary matrices, vectors and other quantities of a DDM solver incurs a computational overhead. For problems with only a few dofs this overhead is not negligible. In conclusion DDM solvers are a very attractive or the only possible option for large scale simulations, especially 3D and some intensive 2D problems.

# Specific DDM solvers 
- [Chapter 3.1 - FETI-1 solver](ch3_1_feti1.md)
- [Chapter 3.2 - FETI-DP solver](ch3_2_fetidp.md)